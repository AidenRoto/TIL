# C 기초 문법 정리

확실하게 외우지 못하고 있던 것들만 정리한다.

## 0. 기본

- `,` 콤마 연산자
    + 둘 이상의 변수 동시 선언할 때. `int a=1, b=2;`
    + 한 줄에 여러 문장을 쓸 때. `a++, b++;`
- 연산 순서: [위키피디아](https://ko.wikipedia.org/wiki/C%EC%99%80_C%2B%2B%EC%97%90%EC%84%9C%EC%9D%98_%EC%97%B0%EC%82%B0%EC%9E%90) 문서 아래쪽에 잘 정리되어있다. 비트 연산자가 논리 연산자보다 앞서고 `&`이 `|`보다 앞선다.
- `scanf` 함수는 데이터의 경계를 공백(빈칸, 탭, 엔터)로 구분한다.
- 비트 연산: 두 숫자에서 같은 위치의 비트끼리 연산한다.
    + `&`, `|` : 두 숫자 사이에서 AND, OR 연산
    + `^` : 두 숫자 사이에서 XOR 연산. 두 개의 비트가 서로 다를 때만 1을 반환한다.
    + `~` : `~a` 형태로 쓰여서 NOT 연산을 한다. 보수 연산이라고도 하며 모든 비트를 반전시킨다. 부호 비트까지 반전된다.
    + `<<`, `>>` : 모든 비트의 위치를 왼쪽, 오른쪽으로 한 칸씩 옮긴다. `a << 2` 형태는 a를 왼쪽으로 2칸 bit shift 연산한다는 의미다. 왼쪽으로 이동하면 우측에 생기는 빈자리는 0으로 채워진다. 우측으로 이동시키면 역시 왼쪽 빈자리에 0이 채워지는데 음수일 경우엔 시스템에 따라 1을 채울지 0을 채울지가 달라진다. 지금 내 맥북은 1이 채워진다.
- NULL 포인터: 가끔 gcc에서 `NULL`을 인식하지 못할 때가 있다. undeclared variable이라고. 그래서 다른 방법으로 선언하고 값을 넣어줘야한다.
    + `float *ptr = (float *)0;`
    + `char *ptr = (char *)0;`
    + `double *ptr = (double *)0;`
    + `char *ptr = '\0';`
    + `int *ptr = NULL;`

## 1. 자료형

### 1.1 숫자 관련

#### 1.1.1 정수형

- `int`
    + 4바이트 공간을 차지한다. 0과 1을 표현하는 비트로 바꾸면 총 32비트다.
    + 가장 왼쪽의 비트는 MSB(Most Significant Bit)라 해서 부호를 나타낸다. 0이면 양수, -1이면 음수다.
    + 31비트만 사용해서 수를 표현하므로 범위가 `-2^32 < int < 2^32` 이다.
    + 음수 계산은 쉽다. 양수를 2진법으로 바꾼 후 -> 보수를 만들고(1과 0을 뒤바꿈) -> 1을 더하면 원래 양수에 -를 붙인 값이 된다. 즉 두 수를 합쳤을 때 1111111 형태가 될텐데 거기서 1을 더하면 한 자리가 초과되면서 넘어간 자리수는 표현이 안되고 나머지 모두가 0이 되버린다. 두 수를 합했을 때 0이 되므로 음수라고 할 수 있는 것이다.
- long
- unsigned int

#### 1.1.2 실수형

- float
- double

### 1.2 문자

- char

### 1.3 문자열

- 문자열 상수와 문자 배열로 나뉜다. 각각 타입은 `char *str`, `char str[]`이다. 이 때 str은 첫 글자를 가리키는 포인터다. 문자열을 출력하거나 인식할 때 `'\0'` 널 문자까지 인식한다.
- 문자열 상수는 각 문자들을 변경할 수 없고, 문자 배열은 가능하다.
- 문자열을 가리키는 포인터에 1씩 더해주면 다음 문자를 가리키게 된다.
- `strlen(str)` 함수는 널문자를 제외한 순수 문자열의 길이를 리턴하고, `sizeof(str)`은 문자열 상수일 경우엔 포인터 변수의 크기를, 문자 배열일 경우엔 전체 문자 배열의 크기를 리턴한다. `str[30]`에 문자열이 `"abcde"`만 들어있더라도 30을 리턴한다.

### 1.4 배열

- `int[] arr = {1, 2, 3};`

## 2. 제어문

### 2.1 for, while 반복문

### 2.2 if, switch

## 3. 라이브러리 만들기

- `gcc -c ft_putchar.c` : `*.c` 파일을 `*.o` 파일로 만든다. `-c` 옵션은 main function 없이 컴파일할 수 있도록 한다.
- `ar rc libstr.a ft_putchar.o ft_putstr.o`
    + `*.o` 파일을 가지고 하나의 라이브러리 파일을 만든다.
    + `ar` : 우리가 사용할 커맨드
    + `rc` : 옵션
    + `libstr.a` : 만들 라이브러리 파일 이름이다. 무조건 맨 앞에 `lib`가 prefix로 붙어야 한다. `str`이 라이브러리 이름, `.a` 확장자는 정적 라이브러리를 의미한다. 동적 라이브러리도 존재함.
- `gcc main.c -L. -lstr`
    + main.c 파일을 컴파일한다.
    + `-L.` : 현재 디렉토리에 있는 라이브러리 파일을 사용한다.
    + `-lstr` : -l은 라이브러리를 의미하고, 우리가 만든 라이브러리의 이름을(str) 명시해준다.
- `ranlib libstr.a` : 라이브러리 파일에 함수가 몇 천개고 매우 크면 컴파일할 때나 불러 쓸 때나 느려진다. 명령어는 라이브러리에 인덱스를 생성해준다.

## 4. 매개변수 불러 쓰기

```c
int main(int argc, char **argv);
```

- `argc`
    + 추가로 입력한 것들의 개수를 의미한다.
    + white-space로 구분해서 하나하나 받아들인다. 만약 공백을 포함하고 싶다면 쌍따옴표로 감싸준다.
    + 파일 명이 언제나 들어가기 때문에 argc는 항상 최소 1이다. 즉 argv[0]은 언제나 존재함.
- `argv` : 문자열을 가리키는 포인터가 들어있는 포인터 배열이다.

## 5. 동적 할당

배열의 길이가 정해지지 않았을 때 코드의 변수를 통해 동적으로 할당하는 방법이다.

### 5.1 malloc

```c
#include <stdlib.h>
#define LEN 42

int     main(void)
{
    int     i;
    char    *str;

    str = (char *)malloc(sizeof(*str) * (LEN + 1));
    i = 0;
    while (i < LEN)
    {
        str[i] = '0' + (i % 10);
        i++;
    }
    str[i] = '\0';
    ft_putstr(str);
    ft_putchar('\n');
    free(str);
    return (0);
}
```

- `#include <stdlib.h>` 라이브러리 사용한다.
- `(char *)` : malloc의 리턴 타입이 void pointer다. 어떤 타입의 배열일지 알 수 없으니까. 그래서 원하는 형태로 캐스팅해줘야 한다.
- `sizeof(*str) * (LEN + 1)` : 어떤 타입이 배열 안에 들어갈지에 따라 메모리 할당 크기가 달라진다. sizeof 함수를 사용하면 쉽게 원소의 크기를 알 수 있고, 이 경우엔 문자열이므로 널 문자까지 계산해서 길이에 1을 더한 값을 곱해줬다.
- `free(str)`
    + 전체 프로그램이 종료되면 결국 사용한 메모리 모두가 해제되지만 직접 해제해주는 것이 좋다.
    + 동적할당한 함수가 종료되더라도 여전히 메모리는 사용 중이다.
    + 할당 받은 메모리가 함수 내부에서만 사용되었다면 함수안에서 free 해야 하고, 함수가 끝나도 유지되어야 한다면 함수를 호출한 쪽에서 free 해야 한다.
    + 안쪽에서부터 순서대로 해야한다. 만약 문자열이 여러개 들어가있는 더블 포인터라면 문자열 하나 하나에 할당된 메모리를 먼저 해제해준 다음, 각 문자열의 주소를 갖고 있는 바깥 배열을 해제해줘야 한다.
- 정수형 배열 `arr`을 포인터 형태로 함수의 매개변수로 전달할 때
    + `int arr[4];`로 정의했다면 무조건 배열 포인터 `int (*ptr)[4]` 형태로 전달해야 한다. 더블 포인터를 쓸 수 없다.
    + `(int *)malloc(sizeof(*arr) * len)` 형태로 동적할당했다면 `int **ptr` 형태로 매개변수전달이 가능하다.

## 6. 입출력

### 6.1 입력

- `#include <stdio.h>` -> `scanf("%d %s %c", &int, str, &c);` : 입력 포맷을 정해주고 입력된 값이 들어갈 변수의 주소값을 넣어준다.
- `#include <stdio.h>` -> `getchar();` 딱 한 글자 char 타입을 불러온다.

### 6.2 출력

- `#include <stdio.h>` -> `printf("%d %s %c", int, str, c);` : 가장 쉽고 편한 출력 함수.
- `#include <stdio.h>` -> `putchar(c);` 한 글자 출력
- `#include <unistd.h>` -> `write(1, &c, 1);` : 캐릭터 하나의 주소값을 받아서 출력하는 함수다. putchar와 비슷

## 7. 전처리기

### 7.1 include

- `#include` : 컴파일 전에 특정 파일을 불러온다. 만약 특정 파일을 include 해놓고 `cpp main.c` 명령어를 쳐 보면 어떤 파일을 불러왔는지 볼 수 있다.
- 제공되는 라이브러리(stdio.h 또는 stdlib.h 같은)는 `#include <stdio.h>` 형태로 쓸 수 있지만 사용자가 직접 만든 라이브러리는 `#include "../my_header.h"` 처럼 적어줘야 한다. 헤더가 현재 파일과 다른 경로에 있다면 표시해줘야 함.

### 7.2 define

- `#define target change` : 딱 그 단어만 바꾼다. abc를 xyz로 바꾼다면 앞 뒤 공백으로 구분된 abc만 잡아서 xyz로 바꾼다. zabc, abcz, zabcz는 바꾸지 않는다. 그리고 문자열 내에 있는 단어 역시 바꾸지 않는다.

### 7.3 선언

- 다른 .c 파일에 있는 함수를 현재 파일에서 쓰려면 맨 위에 선언해줘야 한다.
- 다만 재밌는 것은 다른 파일의 함수의 이름만 똑같이 해주면 리턴 타입과 매개변수는 달라져도 컴파일은 된다. 이렇게 하진 않겠지만 괴상하다.
