# Dynamic Programming - DP

## 1. 개념

- 정의: 어떤 문제를 풀기위해 문제를 잘게 쪼깨고, 그 문제들의 답을 활용하는 방식의 알고리즘

## 2. 피보나치 예제

- 재귀 알고리즘은 다음과 같다. 하지만 메모리를 굉장히 많이 잡아먹는다.

    ```c
    int fibo(int n)
    {
        if(n <= 2)
            return 1;
        else
            return f(n-1)+f(n-2);
    }
    ```

- 그래서 배열을 활용한다.
    + 적절한 배열의 크기를 설정한다. 인덱스 0, 1 자리에는 1을 넣고 나머지엔 0 대입
    + 마지막 계산한 지점의 인덱스를 기록해둔다.
    + 이전의 두 값을 다시 함수로 계산하는게 아니라 그냥 배열에서 값을 가져오기만 한다.

    ```c
    int f_data[100] = {1, 1};
    int last_pos = 1;
    int f(int n)
    {
        int i;

        if (f_data[n-1] == 0) 
        {
            for(i=last_pos+1; i<n; ++i)
            {
                f_data[i] = f_data[i-1] + f_data[i-2];
            }
            last_pos = n-1;
        }
        return f_data[n-1];
    }
    ```

## 3. 다른 예제

- 3항 이상의 재귀 수열
- 0-1 배낭 문제(0-1 Knapsack Problem) : 견딜 수 있는 무게가 제한된 배낭에 가장 많은 가치의 물건을 넣기. 모든 무게를 정수로 볼 수 있다면, 배낭의 최대 무게 W일 때 O(W)로 구할 수 있다. 그게 아닌 경우라면 NP-hard이므로 근사 알고리즘을 써야 한다. 비슷한 것으로 Rational Knapsack Problem이 존재하는데, 이는 보통 Greedy Algorithm으로 사용된다. 0-1 Knapsack고 다른 점은 단순히 물건을 넣느냐 빼느냐가 아니라, 잘라서 (일부분만) 넣을 수 있게 하는 것이다.
- 가장 긴 증가 수열 문제(LIS Problem) : 아무 수열이나 주고, 순서를 바꾸지 않은 상태로 뽑아서 만들 수 있는 가장 긴 증가수열의 길이 구하기. O(N²)이며, 이진 탐색을 사용할 줄 안다면 O(NlogN)으로도 줄일 수 있다.
- 그래프 상의 최단거리 문제 - Floyd, Bellman-Ford. 점 개수가 V일 때 O(V³)으로 구할 수 있다. Floyd는 모든 출발점과 도착점에 대해 최단거리를 구할 수 있고, Bellman-Ford는 거리 합이 음수인 사이클이 있을 때에 대해서도 구할 수 있다. (Dijkstra는 일종의 BFS이다.)
