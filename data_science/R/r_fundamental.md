# R 기초 정리

## 0. 설치

- homebrew 설치한다. [brew.sh](brew.sh) 참고. 터미널에서 다음 코드 입력

```sh
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
```

- 다음 코드 순서대로 터미널에 입력한다. 첫번째 업데이트, 업그레이드를 실행한 후에 `brew doctor`를 입력해서 현재 homebrew에 문제가 없는지 확인해보는 것도 좋다. 두 번째 tap 명령어는 homebrew가 패키지를 다운받기 위해 접속하는 repository를 추가하는 명령어다. r을 실제 설치하기 전에 저 장소를 추가해두면 과학과 관련된 다른 여러 의존성 라이브러리들을 자동으로 설치할 수 있다.

```
brew update && brew upgrade
brew tap homebrew/science
brew install r
```

## 1. 기본

- 터미널에서 `r`을 입력하면 r 전용 REPL이 뜬다. 연습하면 된다. 혹은 Rstudio 써도 괜찮다.
- 확장자 명은 `file_name.R` 이다.
- operator
    + 다른 프로그래밍 언어처럼 `+ - *`는 똑같다.
    + 나누기는 `/` 표현은 같지만 정수를 정수로 나눠도 결과가 정수인 것이 아니라 실수가 된다. 3/2 를 하면 1.5가 나온다. 정수 결과를 얻고싶다면 `3%/%2`를 하면 되고 결과는 1이다.
    + 승수는 `3^2` 형태로 쓴다. 결과는 9
    + 나머지는 `5 %% 3` 형태로 쓴다. 결과는 2
- 논리, 비교연산자 : `<, <=, >=, >` 부등호 연산 다 똑같고, `==, !=` 도 똑같이 쓰이고, not도 `!x` 같은 형태로 사용된다. 논리연산 역시 or은 `|` and는 `&`으로 같다.
- boolean : TRUE, T, FALSE, F 로 쓴다. `isTRUE(x)`로 boolean 체크할 수도 있다.
- NULL(정의되지 않은 값), -Inf, Inf(무한대), NaN(연산 불능일 때), NA(Missing value)
- 복소수는 실제 수학에서 쓰는 그대로 `1 + 2i` 이런식으로 쓰면 된다.
- 대입 : `a = 3` or `a <- 3` 두 형태 모두 가능. 예전엔 `<-`만 있었다는데 `=`가 추가된 것이라고 한다.
- 타입 체크하기
    + `is.integer(x)` 정수
    + `is.numeric(x)` 실수
    + `is.complex(x)` 복소수
    + `is.character(x)` 문자열
    + `is.na(x)` NA 값인지
- 자료구조는 `vector`, `matrix`, `array`, `list`, `data.fram` 다섯가지다.

## 2. 벡터

- 벡터는 모든 속성이 동질적이다. 만들 때 `c(1, 2, 3, 4, 'hi')` 이렇게 만들면 1, 2, 3, 4가 모두 자동으로 문자열로 형 변환이 된다.
- 생성 방법
    + `c(1, 2, 3, 4, 10, 100, 1000)` : 원소 특정
    + `c(1, 2, c(5, 7, 10))` : c 함수를 섞을 수도 있음. 1, 2, 5, 7, 10 됨.
    + `1:10` : 1에서 10까지(10 포함이다) 순서대로 벡터 만들기. 숫자가 `5:1`처럼 역순이 될 수도 있다.
    + `seq(from, to, by)` : from부터 to까지 by 간격으로 벡터 생성. 매개변수 이름 없이 입력하면 from, to, by가 들어간다. 이 때 by는 1이 디폴트값이다. by 대신 `length.out`을 쓸 수도 있는데 원소 수를 지정할 때 쓴다. seq(1, 10, length.out=19) 를 하면 0.5 간격이 자동으로 계산되고 총 19개 원소의 벡터가 생성된다.
    + `rep(data, times, each)` : 반복문 같은 함수를 사용해서도 벡터 생성 가능. 첫 번째 매개변수로는 반복할 자료(벡터)가 들어가고 매개변수 이름 지정해줄 필요 없다. 두 번째 매개변수로 매개변수 이름 지정하지 않으면 디폴트로 times 값이 되고 전체 반복 횟수를 의미한다. each를 써서 원소별 반복횟수를 지정할 수도 있다.
- `length(vector)` : 길이 리턴한다.
- `vector[ ]` : 대괄호 용법
    + 
- 벡터 원소에 이름 지정
    + `c(name = 'data', season = 3)`
    + `names(vector)` : vector에 이름이 뭐가 있는지 알려준다.
    + `names(vector) = c('name1', 'name2')` 이렇게 names 함수에 문자열 벡터를 대입해주게 되면 이름을 입력해주는 역할이다. 없으면 자연스럽게 추가되고, 있었으면 교체된다.
- `mode(object)` : 타입을 알려줌.
- `?func` : 앞에 물음표를 붙이고 함수이름을 치면 함수 정보가 뜬다.

- 벡터의 첫 시작 인덱스는 1이다. 그리고 범위로 쓸 때 '어디까지'를 나타내는 수는 포함이다. 
- 벡터에서 인덱싱 가능: `A_vector[2:5]` 2, 3, 4, 5번째 인덱스의 원소를 뽑아낼 수 있다. `A_vector[c(2, 4, 6)]` 처럼 2, 4, 6번째 원소를 따로 뽑아낼 수도 있다.
- 벡터에서 이름이 있다면 이름으로 접근할 수도 있다. `c()` 함수를 통해서 이름을 지정할 땐 문자열 표시를 따로 하진 않지만, 접근할 때나 `names` 함수로 이름을 지정할 떄는 문자열 형태로 해야 한다. 이름이 열의 이름인가 그 원소 스칼라 원소의 이름인건가.
- 벡터끼리 `+` 연산을 하면 벡터가 이어지는게 아니라 값들이 더해진다. 만약 길이가 같거나, 배수관계에 있다면 정상 동작한다. 배수관계일 때는 짧은 쪽이 반복된다. 하지만 길이가 다른데 배수관계도 아니면 반복되긴 하는데 되다 만다. 그래서 경고 메시지 띄워짐.
- 인덱스에서 `-` 부호를 붙이면 그 부분의 원소가 없는 벡터가 리턴된다. 1, 2, 3, 4가 있는 벡터에서 -4 인덱스를 집어넣으면 1, 2, 3만 나오는 식이다.
- 벡터에 스칼라값으로 연산을 하면 전체 원소에 적용된다. 1, 2, 3 벡터에 1을 빼면 0, 1, 2가 된다. 그리고 벡터를 만들 때 쓰는 `:` 이 `-`보다 연산 우선순위가 높다.
- `all(condition)`, `any(condition)` 함수. 괄호 안에 벡터와 조건을 넣으면 된다. all(A > 0) 이런 식
- `A[A>1]`, `subset(A, A>1)`, `A[which(A>1)]`을 하면 1보다 크다는 조건에 맞는 원소만 뽑힌 벡터가 리턴된다. 그냥 `A>1` 하면 1보다 큰지에 대한 TRUE, FALSE 값이 원소별로 출력된다.

- `class(object)`, `typeof(object)`, `mode(object)` 차이점이 뭐지?




