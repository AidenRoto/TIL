# #60 Don't Eat the Last Cake!

독이 든 케이크가 한 개 있는 케이크들이 있다. 독이 든 것을 먹으면 지는 게임이다. 독 케이크는 명확하게 표시되어있기 때문에 마지막에 먹게될 것이다. 즉 마지막 케이크를 먹는 사람이 지는 게임이다.

- 마지막 케이크를 먹으면 지는 게임
- 자기 턴에 1개, 2개, 3개씩 먹을 수 있는데 앞 턴에 상대가 먹은 수는 고를 수 없다. 앞 턴에 상대가 2개를 먹으면 나는 1개, 3개 중에서만 먹을 수 있다. 첫 시작은 1, 2, 3개 모두 가능
- 만약 앞 턴에 1개를 먹었는데 다음에 케이크가 1개만 남았을 경우엔 턴을 실행할 수 없기 때문에 스킵된다. 그러면 상대가 한 번 더 케이크를 먹게 된다.
- 먼저할지, 나중에할지 선택 가능하다.

Player 클래스를 만드는 문제다. 처음에 시작할지 말지를 결정하는 `firsmove`, 케이크 몇 개를 먹을지 정하는 `move`를 구현하면 된다.

## 1. 내 코드

```py
class Player:
  def __init__(self, cakes):
    self.cakes = cakes
    
  def firstmove(self, cakes):
    return cakes > 2 and cakes % 4 != 2

  def move(self, cakes, last):
    return 3 if cakes % 4 < 3 else 1
```

- 술게임 베스킨라빈스 31의 필승 공식이 적용된다. 상대에게 `4n + 2` 값을 던져주면 무조건 이긴다. 하지만 베스킨라빈스 게임에서와 달리 상대방이 앞턴에 선택한 숫자를 못 고르기 때문에 단순 계산으로 계속 4n+2를 던져줄 순 없다. 예를 들어 컴퓨터가 10에서 2를 골라 8을 내게 줬을 때, 내가 다시 2를 줘서 4n+2인 6을 던져줄 수 없다. 2가 이미 쓰였기 때문이다.
- `firstmove`: 케이크 시작 수가 4n+2일 때만 상대부터 시작하게 해주면 되고, 나머지는 내가 먼저 시작한다. 다만 케이크 수가 1일 땐 상대가 먼저 시작하게 해야한다.
- `move`
    + `4n+3`: 1을 골라서 4n+2를 상대에게 준다. 내 턴에 4n+3이 되는 경우는 게임 시작 때 혹은 아래 4n의 경우에서 내가 3을 고르고 상대가 2를 고른 경우다. 즉 내가 1을 고르지 못할 경우의 수는 없다.
    + `4n+1`: 3을 골라서 4n+2를 상대에게 준다. 4n+1이 내 턴에 오는 경우 역시 게임 시작 때와 상대가 4n+2였을 때 1을 고른 경우다. 역시 내가 3을 고르지 못할 경우는 없다.
    + `4n`: 가장 중요한 부분이다. 같은 방식으로 2를 고르는 것이 아니라 3을 고른다. 그러면 4n+1이 상대에게 넘어가게 되고 1이나 2만 고를 수 있게 된다. 상대가 1을 고르면 다시 4n이 나에게 넘어오게 되고, 2를 고르면 4n+3이 되어서 내가 다시 1을 골라 4n+2를 상대에게 줄 수 있다. 4n+2도 losing position이지만 4n도 그렇다. 계속 4n이 상대에게 넘어가게 되면 결국 내가 4에서 3을 골라 1을 주게된다.
    + `4n+2`: 위 3가지 경우에서 계속 회피했기 때문에 불가능한 사건이다.
