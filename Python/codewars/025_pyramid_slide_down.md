# #25 Pyramid Slide Down

숫자 피라미드의 위에서 아래로 내려오는 루트 중 모든 숫자의 합이 가장 큰 경우 합을 구하는 문제

## 1. 내 코드

3시간 정도 어떻게 짤지 고민하다가 결국 포기하고 답을 검색했다. 링크 하나를 클릭했는데 다음 이미지가 떴다.

![tip](http://www.mathblog.dk/files/2010/12/subproblems.png)

> 패배자 느낌이 든다. 25개 문제를 푸는 동안 처음으로 답을 검색했다. 제..젠장.. 하..

- 보는 순간 아!하고 영감을 얻고 설명 글은 읽지 않은채 첫 번째 답을 작성했다.
    + 재귀를 활용한 코드다. 피라미드 리스트를 입력받으면 위 이미지처럼 아래 부분을 2개의 피라미드로 분리한다. 그리고 다시 그 두 피라미드를 함수에 넣는다.
    + 맨 아래까지 도착하면 아래 두 수 중 큰 수를 위 열의 수에 더해서 리턴하고, 쭉 올라와서 최종 답을 도출한다.
    + 그런데 이건 너무 느렸다.
- 도대체 이걸 어떻게 빨리 만들까. 설마 더 나은 방법이 있는걸까 고민하다가 기진맥진하여 다시 답을 검색했다.(한 번 포기하면 다음 포기는 더 빠르다..)
    + 맨 아래 리스트에서 바로 위 리스트로 큰 수를 합산하는 방법이었다. 첫 번째 방법과 큰 틀은 같지만 재귀보다는 훨씬 빨랐다.
    + 메모리 사용량 차이일까. 리스트를 쪼개고 또 쪼개고, 그런 function scope를 2의 피라미드 수 - 1 승개(11칸 짜리면 1024개, 21칸 짜리면 100만개가 넘는다) 저장하면서 연산하는 것보다는 리스트 하나 저장하는게 더 나아서 그런 것 같다.

```python
# 재귀를 활용하는 코드. 느리다.
def longest_slide_down(pyramid):
    if len(pyramid) == 2: return pyramid[0][0] + max(pyramid[1])
    left = longest_slide_down([i[:-1] for i in pyramid][1:]) # left
    right = longest_slide_down([i[1:] for i in pyramid][1:]) # right
    return pyramid[0][0] + max(left, right)

# 마지막 리스트를 계속 없애나가는 것.
def longest_slide_down(pyramid):
    if len(pyramid) == 2: return pyramid[0][0] + max(pyramid[1])
    for i in range(len(pyramid) - 2):
        for j in range(len(pyramid[-2])):
            pyramid[-2][j] += max(pyramid[-1][j], pyramid[-1][j+1])
        del pyramid[-1]
    return pyramid[0][0] + max(pyramid[1])

# 샘플 피라미드. 결과: 1074
pyramid = [
[75],
[95, 64],
[17, 47, 82],
[18, 35, 87, 10],
[20,  4, 82, 47, 65],
[19,  1, 23, 75,  3, 34],
[88,  2, 77, 73,  7, 63, 67],
[99, 65,  4, 28,  6, 16, 70, 92],
[41, 41, 26, 56, 83, 40, 80, 70, 33],
[41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
[53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
[70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
[91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
[63, 66,  4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
[ 4, 62, 98, 27, 23,  9, 70, 98, 73, 93, 38, 53, 60,  4, 23]
]
```

## 2. 다른 해답

모든 답이 두 번째 알고리즘과 동일했다. 그 중 가장 읽기 편한 답으로 골랐다.

```python
def longest_slide_down(p):
    res = p.pop()
    while p:
        tmp = p.pop()
        res = [tmp[i] + max(res[i],res[i+1])  for i in range(len(tmp))] 
    return res.pop()
```
