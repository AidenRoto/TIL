# Redux

React가 View를 관리하는 라이브러리라면 Redux는 데이터를 관리하는 라이브러리다.

## 1. Reducer

### 1.1 개념

```js
// Application State - Generated by reducers
{
    books: [{title: 'Harry Potter'}, {title:'JavaScript'}],
    activeBook: {title: 'JavaScript'}
}
```

- Application-level state는 single object다.
- `books와` `activeBook은` 각각 다른 reducer에 의해 생성된다. books는 Books Reducer에 의해, activeBook은 ActiveBook reducer에 의해서.
- 즉 reducer는 application-level state의 value 부분이고, 이 value를 만들어내는 것이라 표현해도 된다. key 이름은 맘대로 해도 된다.
- 데이터 종류가 두 개라면 reducer도 2개다. Application-level state object에 2개의 요소가 속해있는 셈.
- 데이터가 하나면 하나의 object가 value가 되지만, 두 개라면 Array에 여러개의 object가 들어간다.
- `reducers` 폴더의 각 데이터 js 파일들은 같은 위치의 `index.js` 파일에 import 되어서 아래 코드처럼 뭉쳐지고, global state가 된다.

### 1.2 생성 및 연결

- 루트 디렉토리의 `src` 폴더 안에 `reducers` 폴더를 만든다.
- reducers 폴더 내에 js 파일을 만드는데 파일 명 앞에 `reducer_books.js`처럼 'reducer_'를 붙여주면 좋다. 강사가 추천하는 convention이다.

```js
// reducers/index.js
import { combineReducers } from 'redux';
import BooksReducer from './reducer_books';
const rootReducer = combineReducers({
  books: BooksReducer
});
export default rootReducer;

// reducers/reducer_books.js
export default function() {
  return [
    { title: 'JavaScript: Good Parts' },
    { title: 'Harry Potter' },
    { title: 'The Dark Tower' },
    { title: 'Eloquent Ruby'}
  ]
}
```

- 위처럼 index.js 파일에서 reducer들을 합치게 된다.
- 재밌는 것은 reducer_books에서 export할 때의 객체명은 import할 때 아무 상관이 없다. index.js 파일에서 BooksReducer라고 지칭한 것은 reducer_books.js 파일에서 객체 명과 아무런 상관이 없다. 레퍼런스 명은 독립적이다.

## 2. Container

- 가지고 있는 Component 중 하나를 Container라고 정할 것이다. 지금까지 했던 예제에선 View로 쓰였지만 데이터 container로 쓸 것이다. container는 Redux의 state와 직접 바로 연결되어있는 component를 말한다.
- View를 담당하는 React와 Data를 담당하는 Redux의 bridge 역할을 하는 것이 이 container다. `smart component`라고도 불리는데 redux와 접점이 없는 일반 component를 이르는 `dumb components`의 반대 개념이다.
- src 폴더에 `containers` 폴더를 만들어서 여기에 파일을 만든다. 이전에 만들었던 book_list.js 파일을 components 폴더에서 containers 폴더로 옮긴다. 즉 이 파일을 container로 쓰겠다는 의미.

![select-container](http://i.imgur.com/0pLp101.png)

- 어떤 component를 container로 바꿔야할까. 이건 다양한 방법이 있다.
- 위 이미지에서처럼 딱 그 state만 관리하는 component 중 가장 상위의 것을 선택하면 된다. 즉 App은 books도 관리하고 selectedBook도 관리하기 때문에 상위 component지만 적합하지 않다.
- 더 실용적인 이유는 React에서 state가 바뀌면 render를 바로 다시하게 되는데 만약 App을 container로 잡았다면 selectedBook state가 바뀌었을 때 books까지 전체가 모두 불필요하게 render되게 된다. 그래서 다른 state가 연관되지 않은 최상위 부분만 container로 지정하는 것이 좋다.

## 3. React, Redux 연결하기

```js
// book_list.js 파일 수정
import React, { Component } from 'react';
import { connect } from 'react-redux';

class BookList extends Component {
  renderList() {
    return this.props.books.map((book) => {
      return (
        <li key={book.title} className="list-group-item ">{book.title}</li> ///
      );
    })
  }

  render() {
    return (
      <ul className="list-group col-sm-4">
        {this.renderList()}
      </ul> ///
    );
  }
}

function mapStateToProps(state) {
  // Whatever is returned will show up as props inside of BookList
  // 리턴값은 this.props와 동일하다
  return {
    books: state.books
  }
}

export default connect(mapStateToProps)(BookList);
```

- 내부적으로 둘이 연결되어있지 않다. 완전히 개별적인 라이브러리다. 직접 연결해야된다. 다음처럼 먼저 import 한다. `import { connect } from 'react-redux';`
- `mapStateToProps`: application-level state를 argument로 받는 함수다. 이번 예제에선 books와 selectedBook이 될 것이다. 이 함수의 리턴값은 `this.props`와 동일하다. 해당 클래스에서 this.props.something 해서 얼마든지 쓸 수 있다.
- `BookList` container에서 활용하는 데이터는 books이므로 mapStateToProps 함수에선 위처럼 return값을 조정해준다.
- 마지막으로 import했던 connect 함수를 활용해서 마지막 export에서 적힌 것처럼 적어준다. 일반 BookList component가 아니라 mapStateToProps로 Redux와 연결된 container를 만들어서 export하는 것이다.
- 그리고 위 경우에선 기존 Component 만들 때와 달리 this.state가 constructor에 없다. 하지만 Redux와 mapStateToProps로 연결되면서 state가 바뀌면 BookList도 바로바로 다시 render되게 된다.

## 4. Actions

### 4.1 개념

![Imgur](http://i.imgur.com/9P9HN0H.png)

- 웹 페이지에서 변화는 유저의 클릭 같은 직접적인 이벤트 트리거나, 로딩이 끝난 시점 같은 간접적인 트리거로 시작된다. Redux 구조 하에서 이벤트 트리거가 일어나면 Action Creator가 호출된다.
- Action Creator는 Action object를 리턴하는 function이다. object 내에는 Type과 데이터가 존재한다.
    + `type`: action을 설명하는 문자열 상수
    + data: reducer에서 생성하는 데이터처럼 적으면 된다.
- action은 자동으로 모든 reducer에게 보내진다. 그래서 주로 위 그림에서도 볼 수 있듯이 reducer에서 `switch`문으로 type을 분기해서 특정 작업을 하게된다. 특정 작업은 주로 action의 요소로 들어온 데이터를 리턴하는 작업이다.
- reducer가 state와 연결되어있기 때문에 리턴하면 연결된 state의 한 요소의 값을 바꾸게 된다. 위 그림에서는 `{title:Javascript}` 부분이 `{title:Book 2}`로 바뀌는 것이다.
- 그 후에 state가 변했다는 것을 container에 알리게 되고, 그 container가 다시 render되게 된다.

### 4.2 Action 연결 시키기

- `actions/index.js` 파일에 action creator function을 만든다.
    + action, 즉 js plain object를 리턴하는 것이고 type과 payload(데이터) property를 갖는다. type은 주로 문자열 상수 variable인데 일단은 아래처럼 적어두었다.

    ```js
    export default function selectBook(book) {
      // selectBook is a action creator.
      // It needs to return an action, an object with a type property.
      return {
        type: 'BOOK_SELECTED',
        payload: book
      };
    }
    ```

- 만들어진 function이 book list 화면에서 특정 책 부분이 선택될 때마다 호출되어야 하므로 `book_list.js`에 import시킨다. `import { selectBook } from '../actions/index';`
- action을 모든 reducer에 보내는 역할을 하는 `bindActionCreators` 함수를 import 한다. `import { bindActionCreators } from 'redux';`
- 아래쪽에 `mapDispatchToProps` 함수를 만들고, `connect` 함수의 매개변수로 추가해준다. 아래 코드.
    + `dispatch`는 callback function인데 모든 action을 받아서 reducer 각각에 뿌려주는 역할을 한다.
    + `mapDispatchToProps` 함수 역시 `mapStateToProps`와 같은 역할을 한다. `this.props`에서 호출해서 사용할 수 있도록 만든다. 아래 코드에서는 key인 selectBook이 this.props.selectBook 형태로 호출 가능해진다.

    ```js
    function mapDispatchToProps(dispatch) {
      return bindActionCreators({ selectBook : selectBook }, dispatch);
    }
    export default connect(mapStateToProps, mapDispatchToProps)(BookList);
    ```

### 4.3 event 연결

```js
renderList() {
  return this.props.books.map((book) => {
    return (
      <li
        key={book.title}
        onClick={ () => this.props.selectBook(book) }
        className="list-group-item ">
        {book.title}
      </li> ///
    );
  })
}
```

- `book_list.js` 파일의 `renderList` 함수를 수정한다. li element에 click event를 넣어준다.

## 5. Active Book 부분 구현

### 5.1 reducer 만들기

```js
export default function(state=null, action) {
  switch(action.type) {
    case 'BOOK_SELECTED':
      return action.payload;
  }
  return state
}
```

- 모든 reducer는 두 개의 매개변수를 받는다.
    + `state` : application level이 아니라 해당 reducer가 관리하는 state다.
    + `action`
- `undefined`를 리턴하면 에러가 나므로 state의 기본값이 null이 되도록 값을 지정해준다.
- reducer 안에서 state를 mutate하는 일은 없어야 한다. 함수의 내용은 정말 단순하게 특정 type에서 어떤 state를 리턴할 것인지 정도여야 한다. state의 값을 조정하면 안된다.
- `reducers/index.js` 파일에 `ActiveBookReducer`를 import한다.

    ```js
    import { combineReducers } from 'redux';
    import BooksReducer from './reducer_books';
    import ActiveBookReducer from './reducer_active_book';

    const rootReducer = combineReducers({
      books: BooksReducer,
      activeBook: ActiveBookReducer
    });

    export default rootReducer;
    ```

## 요약

- 모든 데이터, 상태는 하나의 state tree에 저장이 된다.
- state tree 는 read only 하다. action을 통해서만 상태를 변경할수 있다.
- Only Pure Function
    + 입력받은 인자의 값을 직접 수정하지 않는다. 새롭게 객체를 복사해 생성한 다음 이에 새로운 상태를 추가, 수정한다.
    + side effect가 일어나서는 안된다. api 를 부른다거나 하는 예측 불가능한 다른 행동을 해서는 안되고 오직 입력받은 데이터를 기반으로한 동작만 진행한다.
    + 모든 데이터를 single object에 집어넣는다. state라고 한다. component 다룰 때 썼던 state와는 다르다. application level의 state다.
