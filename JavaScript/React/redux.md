# Redux

1. 모든 데이터, 상태는 하나의 state tree에 저장이 된다.

2. state tree 는 read only 하다. action을 통해서만 상태를 변경할수 있다.

3. Only Pure Function
-입력받은 인자의 값을 직접 수정하지 않는다. 새롭게 객체를 복사해 생성한 다음 이에 새로운 상태를 추가, 수정한다.
- side effect가 일어나서는 안된다. api 를 부른다거나 하는 예측 불가능한 다른 행동을 해서는 안되고 오직 입력받은 데이터를 기반으로한 동작만 진행한다.

모든 데이터를 single object에 집어넣는다. state라고 한다. component 다룰 때 썼던 state와는 다르다. application level의 state다.

## 1. Reducer

### 1.1 개념

```js
// Application State - Generated by reducers
{
    books: [{title: 'Harry Potter'}, {title:'JavaScript'}],
    activeBook: {title: 'JavaScript'}
}
```

- Application-level state는 single object다.
- books와 activeBook은 각각 다른 reducer에 의해 생성된다. books는 Books Reducer에 의해, activeBook은 ActiveBook reducer에 의해서.
- 즉 reducer는 application-level state의 value 부분이고, 이 value를 만들어내는 것이라 표현해도 된다. key 이름은 맘대로 해도 된다.
- 데이터 종류가 두 개라면 reducer도 2개다. Application-level state object에 2개의 요소가 속해있는 셈.
- 데이터가 하나면 하나의 object가 value가 되지만, 두 개라면 Array에 여러개의 object가 들어간다.

### 1.2 생성 및 연결

- 루트 디렉토리의 `src` 폴더 안에 `reducers` 폴더를 만든다.
- reducers 폴더 내에 js 파일을 만드는데 파일 명 앞에 `reducer_books.js`처럼 'reducer_'를 붙여주면 좋다. 강사가 추천하는 convention이다.

```js
// reducers/index.js
import { combineReducers } from 'redux';
import BooksReducer from './reducer_books';
const rootReducer = combineReducers({
  books: BooksReducer
});
export default rootReducer;

// reducers/reducer_books.js
export default function() {
  return [
    { title: 'JavaScript: Good Parts' },
    { title: 'Harry Potter' },
    { title: 'The Dark Tower' },
    { title: 'Eloquent Ruby'}
  ]
}
```

- 위처럼 index.js 파일에서 reducer들을 합치게 된다.
- 재밌는 것은 reducer_books에서 export할 때의 객체명은 import할 때 아무 상관이 없다. index.js 파일에서 BooksReducer라고 지칭한 것은 reducer_books.js 파일에서 객체 명과 아무런 상관이 없다. 레퍼런스 명은 독립적이다.

## 2. Container

- 가지고 있는 Component 중 하나를 Container라고 정할 것이다. 지금까지 했던 예제에선 View로 쓰였지만 데이터 container로 쓸 것이다. container는 Redux의 state와 직접 바로 연결되어있는 component를 말한다.
- View를 담당하는 React와 Data를 담당하는 Redux의 bridge 역할을 하는 것이 이 container다. `smart component`라고도 불리는데 redux와 접점이 없는 일반 component를 이르는 `dumb components`의 반대 개념이다.
- src 폴더에 `containers` 폴더를 만들어서 여기에 파일을 만든다. 이전에 만들었던 book_list.js 파일을 components 폴더에서 containers 폴더로 옮긴다. 즉 이 파일을 container로 쓰겠다는 의미.

![select-container](http://i.imgur.com/0pLp101.png)

- 어떤 component를 container로 바꿔야할까. 이건 다양한 방법이 있다.
- 위 이미지에서처럼 딱 그 state만 관리하는 component 중 가장 상위의 것을 선택하면 된다. 즉 App은 books도 관리하고 selectedBook도 관리하기 때문에 상위 component지만 적합하지 않다.
- 더 실용적인 이유는 React에서 state가 바뀌면 render를 바로 다시하게 되는데 만약 App을 container로 잡았다면 selectedBook state가 바뀌었을 때 books까지 전체가 모두 불필요하게 render되게 된다. 그래서 다른 state가 연관되지 않은 최상위 부분만 container로 지정하는 것이 좋다.

## 3. React, Redux 연결하기

```js
// book_list.js 파일 수정
import React, { Component } from 'react';
import { connect } from 'react-redux';

class BookList extends Component {
  renderList() {
    return this.props.books.map((book) => {
      return (
        <li key={book.title} className="list-group-item ">{book.title}</li> ///
      );
    })
  }

  render() {
    return (
      <ul className="list-group col-sm-4">
        {this.renderList()}
      </ul> ///
    );
  }
}

function mapStateToProps(state) {
  // Whatever is returned will show up as props inside of BookList
  // 리턴값은 this.props와 동일하다
  return {
    books: state.books
  }
}

export default connect(mapStateToProps)(BookList);
```

- 내부적으로 둘이 연결되어있지 않다. 완전히 개별적인 라이브러리다. 직접 연결해야된다. 다음처럼 먼저 import 한다. `import { connect } from 'react-redux';`
- `mapStateToProps`: application-level state를 argument로 받는 함수다. 이번 예제에선 books와 selectedBook이 될 것이다. 이 함수의 리턴값은 `this.props`와 동일하다. 해당 클래스에서 this.props.something 해서 얼마든지 쓸 수 있다.
- `BookList` container에서 활용하는 데이터는 books이므로 mapStateToProps 함수에선 위처럼 return값을 조정해준다.
- 마지막으로 import했던 connect 함수를 활용해서 마지막 export에서 적힌 것처럼 적어준다. 일반 BookList component가 아니라 mapStateToProps로 Redux와 연결된 container를 만들어서 export하는 것이다.
- 그리고 위 경우에선 기존 Component 만들 때와 달리 this.state가 constructor에 없다. 하지만 Redux와 mapStateToProps로 연결되면서 state가 바뀌면 BookList도 바로바로 다시 render되게 된다.
